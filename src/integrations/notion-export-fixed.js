/**
 * Notion Export Integration f√ºr Otto Assistant - FIXED Version
 * Erweitert f√ºr Creative Agency Features mit dynamischer Property-Erkennung
 */

const fs = require("fs");
const path = require("path");
const axios = require("axios");
const { notionCreativeSelector } = require("./notion-creative-templates");
const { selectBestTemplate } = require("../utils/summary-templates");

// Lade Notion-API-Konfiguration aus config.json
let config = {};
try {
  const configPath = path.resolve(__dirname, "../../config.json");
  config = JSON.parse(fs.readFileSync(configPath, "utf8"));
} catch (e) {
  console.warn("‚ö†Ô∏è Konnte config.json nicht laden, Notion-Export deaktiviert.");
}

const NOTION_API_BASE = "https://api.notion.com/v1";
const NOTION_VERSION = "2022-06-28";

/**
 * Exportiert Transkript und Zusammenfassung als Notion-Page mit dynamischer Property-Erkennung
 */
async function exportToNotion(transcript, summary, entities = [], entityEmojis = {}, options = {}) {
  const apiKey = config.NOTION_API_KEY || process.env.NOTION_API_KEY;
  const databaseId = config.NOTION_DATABASE_ID || process.env.NOTION_DATABASE_ID;
  
  if (!apiKey) {
    console.error("‚ùå Notion API-Key fehlt.");
    return null;
  }
  
  if (!databaseId) {
    console.error("‚ùå Notion Database-ID fehlt.");
    return null;
  }

  try {
    // 1. Template-Typ ermitteln
    const templateType = options.templateType || selectBestTemplate(transcript);
    console.log(`üé® Notion Template-Typ: ${templateType}`);
    
    // 2. Database Schema abfragen um verf√ºgbare Properties zu ermitteln
    const databaseResponse = await axios.get(`${NOTION_API_BASE}/databases/${databaseId}`, {
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Notion-Version": NOTION_VERSION
      }
    });
    
    const availableProperties = Object.keys(databaseResponse.data.properties);
    console.log(`üìã Database Properties: ${availableProperties.join(', ')}`);
    
    // 3. Template Data erstellen
    const templateData = notionCreativeSelector.extractTemplateData(
      transcript, 
      summary, 
      templateType, 
      entities, 
      entityEmojis
    );
    
    // 4. Kompatible Properties basierend auf Database Schema erstellen
    const properties = createCompatibleProperties(
      databaseResponse.data.properties,
      transcript,
      summary,
      templateType,
      entities,
      entityEmojis,
      templateData
    );
    
    console.log(`‚úÖ Properties erstellt: ${Object.keys(properties).join(', ')}`);
    
    // 5. Content erstellen
    const template = notionCreativeSelector.selectTemplate(transcript, summary, templateType);
    const content = notionCreativeSelector.createPageContent(template, transcript, summary, templateData);
    
    // 6. Notion Page erstellen
    const pageData = {
      parent: { database_id: databaseId },
      properties: properties,
      children: createNotionBlocks(content)
    };
    
    console.log(`üöÄ Erstelle Notion Page...`);
    const response = await axios.post(`${NOTION_API_BASE}/pages`, pageData, {
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Notion-Version": NOTION_VERSION,
        "Content-Type": "application/json"
      }
    });
    
    const pageUrl = response.data.url;
    console.log(`‚úÖ Notion Page erstellt: ${pageUrl}`);
    
    return pageUrl;
    
  } catch (error) {
    console.error("‚ùå Notion Export fehlgeschlagen:", error.response?.data || error.message);
    return null;
  }
}

/**
 * Erstellt kompatible Properties basierend auf der Database-Schema
 */
function createCompatibleProperties(databaseProperties, transcript, summary, templateType, entities, entityEmojis, templateData) {
  const properties = {};
  
  // Durchlaufe verf√ºgbare Database Properties
  for (const [propName, propConfig] of Object.entries(databaseProperties)) {
    const propType = propConfig.type;
    
    try {
      // Title Property (meist der erste)
      if (propType === 'title') {
        properties[propName] = {
          title: [{ 
            type: "text", 
            text: { content: summary.substring(0, 100) || "Otto Meeting" }
          }]
        };
      }
      
      // Rich Text Properties
      else if (propType === 'rich_text') {
        let content = "";
        const lowerPropName = propName.toLowerCase();
        
        if (lowerPropName.includes('summary')) {
          content = summary;
        } else if (lowerPropName.includes('transcript') || lowerPropName.includes('content')) {
          content = transcript.substring(0, 2000);
        } else if (lowerPropName.includes('description')) {
          content = templateData.description || summary;
        } else if (lowerPropName.includes('notes')) {
          content = templateData.keyPoints?.join('\n') || "Generated by Otto Creative Assistant";
        } else {
          content = "Generated by Otto Creative Assistant";
        }
        
        properties[propName] = {
          rich_text: [{ 
            type: "text", 
            text: { content: content.substring(0, 2000) }
          }]
        };
      }
      
      // Select Properties
      else if (propType === 'select') {
        let value = "";
        const lowerPropName = propName.toLowerCase();
        
        if (lowerPropName.includes('type') || lowerPropName.includes('template')) {
          value = templateType.replace('_', ' ');
        } else if (lowerPropName.includes('status')) {
          value = "Active";
        } else if (lowerPropName.includes('priority')) {
          value = "Medium";
        } else {
          value = "Otto Generated";
        }
        
        properties[propName] = {
          select: { name: value }
        };
      }
      
      // Multi-Select Properties
      else if (propType === 'multi_select') {
        let tags = [];
        const lowerPropName = propName.toLowerCase();
        
        if (lowerPropName.includes('tag') || lowerPropName.includes('label')) {
          tags = entities.slice(0, 3).map(entity => ({ name: entity }));
          if (tags.length === 0) {
            tags = [{ name: "Otto" }, { name: "Creative" }];
          }
        } else {
          tags = [{ name: "Otto" }, { name: templateType.replace('_', ' ') }];
        }
        
        properties[propName] = {
          multi_select: tags
        };
      }
      
      // Date Properties
      else if (propType === 'date') {
        properties[propName] = {
          date: { start: new Date().toISOString().split('T')[0] }
        };
      }
      
      // Number Properties
      else if (propType === 'number') {
        properties[propName] = {
          number: entities.length || 1
        };
      }
      
      // Checkbox Properties
      else if (propType === 'checkbox') {
        properties[propName] = {
          checkbox: true
        };
      }
      
      // URL Properties
      else if (propType === 'url') {
        properties[propName] = {
          url: "https://github.com/your-repo/otto-assistant"
        };
      }
      
    } catch (propError) {
      console.log(`‚ö†Ô∏è Property ${propName} √ºbersprungen:`, propError.message);
    }
  }
  
  return properties;
}

/**
 * Erstellt Notion Blocks aus Markdown-Content
 */
function createNotionBlocks(content) {
  const blocks = [];
  const lines = content.split('\n');
  
  for (const line of lines) {
    const trimmedLine = line.trim();
    
    if (!trimmedLine) continue;
    
    // Headers
    if (trimmedLine.startsWith('# ')) {
      blocks.push({
        object: "block",
        type: "heading_1",
        heading_1: {
          rich_text: [{ type: "text", text: { content: trimmedLine.substring(2) } }]
        }
      });
    } else if (trimmedLine.startsWith('## ')) {
      blocks.push({
        object: "block",
        type: "heading_2",
        heading_2: {
          rich_text: [{ type: "text", text: { content: trimmedLine.substring(3) } }]
        }
      });
    } else if (trimmedLine.startsWith('### ')) {
      blocks.push({
        object: "block",
        type: "heading_3",
        heading_3: {
          rich_text: [{ type: "text", text: { content: trimmedLine.substring(4) } }]
        }
      });
    }
    // Bullet Lists
    else if (trimmedLine.startsWith('- ')) {
      blocks.push({
        object: "block",
        type: "bulleted_list_item",
        bulleted_list_item: {
          rich_text: [{ type: "text", text: { content: trimmedLine.substring(2) } }]
        }
      });
    }
    // Numbered Lists
    else if (/^\d+\.\s/.test(trimmedLine)) {
      blocks.push({
        object: "block",
        type: "numbered_list_item",
        numbered_list_item: {
          rich_text: [{ type: "text", text: { content: trimmedLine.replace(/^\d+\.\s/, '') } }]
        }
      });
    }
    // Dividers
    else if (trimmedLine === '---') {
      blocks.push({
        object: "block",
        type: "divider",
        divider: {}
      });
    }
    // Regular paragraphs
    else {
      if (trimmedLine && !trimmedLine.startsWith('**') && !trimmedLine.startsWith('*')) {
        blocks.push({
          object: "block",
          type: "paragraph",
          paragraph: {
            rich_text: [{ type: "text", text: { content: trimmedLine } }]
          }
        });
      }
    }
  }
  
  return blocks;
}

/**
 * Test-Funktion f√ºr Notion Export
 */
async function testNotionExport() {
  const testData = {
    transcript: `
      Client: Mercedes-Benz
      Projekt: EQS Kampagne 2025
      Zielgruppe: Premium-Kunden, umweltbewusst
      Botschaft: Luxus trifft Nachhaltigkeit
      Team: Sarah (Creative Director), Max (Art Director)
    `,
    summary: "Creative Briefing f√ºr Mercedes EQS Elektro-Kampagne",
    entities: ['Mercedes-Benz', 'EQS', 'Kampagne', 'Premium'],
    entityEmojis: { 'Mercedes-Benz': 'üöó', 'EQS': '‚ö°', 'Kampagne': 'üì¢' }
  };
  
  console.log("üß™ Testing Fixed Notion Export...");
  const result = await exportToNotion(
    testData.transcript,
    testData.summary,
    testData.entities,
    testData.entityEmojis,
    { templateType: 'creative_briefing' }
  );
  
  if (result) {
    console.log("‚úÖ Fixed Notion Export Test erfolgreich!");
    console.log("üîó Page URL:", result);
  } else {
    console.log("‚ùå Fixed Notion Export Test fehlgeschlagen!");
  }
}

module.exports = {
  exportToNotion,
  testNotionExport,
  createCompatibleProperties
};
